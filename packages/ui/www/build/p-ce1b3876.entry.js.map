{"version":3,"names":["treeCss","Tree","constructor","hostRef","this","empty","emptyState","subscribers","componentWillLoad","parseEmptyState","getSelectedNode","selectedNode","handleKeyDown","evt","path","composedPath","menuItem","elm","tagName","key","preventDefault","focusNextItem","focusPreviousItem","internalEmptyState","JSON","parse","render","h","class","renderEmptyState","setFocus","firstMenuItem","getFirstItem","subscribeToSelect","cb","push","treeNodeClick","detail","value","forEach","currentItem","nextItem","nextElementSibling","disabled","querySelector","previousItem","previousElementSibling","Object","assign"],"sources":["src/components/tree/tree/tree.scss?tag=zane-tree&encapsulation=shadow","src/components/tree/tree/tree.tsx"],"sourcesContent":["@use '../../../global/styles/commons';\n\n:host {\n  display: block;\n}\n\n.tree-view {\n  background-color: var(--layer);\n}\n","import {\n  Component,\n  ComponentInterface,\n  Element,\n  h,\n  Listen,\n  Method,\n  Prop,\n  State,\n  Watch,\n} from '@stencil/core';\n\n/**\n * @name Tree\n * @description A tree view is a hierarchical structure that provides nested levels of navigation.\n * @category Navigation\n * @subcategory Tree View\n * @img /assets/img/tree-view.webp\n * @imgDark /assets/img/tree-view-dark.webp\n */\n@Component({\n  shadow: true,\n  styleUrl: 'tree.scss',\n  tag: 'zane-tree',\n})\nexport class Tree implements ComponentInterface {\n  @Element() elm!: HTMLElement;\n\n  @Prop({ mutable: true }) empty: boolean = false;\n\n  @Prop({ mutable: true }) emptyState: string = `{\n    \"headline\": \"No items\",\n    \"description\": \"There are no items to display\"\n  }`;\n\n  @State()\n  internalEmptyState: any;\n\n  @Prop({ mutable: true })\n  selectedNode: string;\n\n  subscribers: any[] = [];\n\n  componentWillLoad() {\n    this.parseEmptyState();\n  }\n\n  @Method()\n  async getSelectedNode() {\n    return this.selectedNode;\n  }\n\n  @Listen('keydown', { target: 'window' })\n  handleKeyDown(evt: KeyboardEvent) {\n    const path = evt.composedPath();\n    let menuItem = null;\n    for (const elm of path) {\n      if ((elm as any).tagName === 'ZANE-TREE-NODE') {\n        menuItem = elm;\n      }\n      if (elm !== this.elm) continue;\n      if (evt.key === 'ArrowDown') {\n        evt.preventDefault();\n        this.focusNextItem(menuItem);\n      } else if (evt.key === 'ArrowUp') {\n        evt.preventDefault();\n        this.focusPreviousItem(menuItem);\n      }\n    }\n  }\n\n  @Watch('emptyState')\n  parseEmptyState() {\n    this.internalEmptyState =\n      typeof this.emptyState === 'string'\n        ? JSON.parse(this.emptyState)\n        : this.emptyState;\n  }\n\n  render() {\n    return this.empty ? (\n      <div class=\"tree-view\">{this.renderEmptyState()}</div>\n    ) : (\n      <div class=\"tree-view\">\n        <slot></slot>\n      </div>\n    );\n  }\n\n  /**\n   * Sets focus on first menu item. Use this method instead of the global\n   * `element.focus()`.\n   */\n  @Method()\n  async setFocus() {\n    const firstMenuItem = this.getFirstItem();\n    (firstMenuItem as any)?.setFocus();\n  }\n\n  @Method()\n  async subscribeToSelect(cb) {\n    this.subscribers.push(cb);\n  }\n\n  @Listen('zane-tree-node--click')\n  treeNodeClick(evt: CustomEvent<any>) {\n    this.selectedNode = evt.detail.value;\n    this.subscribers.forEach((cb) => cb(evt.detail.value));\n  }\n\n  private focusNextItem(currentItem) {\n    let nextItem: any = currentItem.nextElementSibling;\n    do {\n      if (\n        nextItem &&\n        nextItem.tagName === 'ZANE-TREE-NODE' &&\n        !nextItem.disabled\n      ) {\n        nextItem.setFocus();\n        return;\n      }\n      nextItem = nextItem\n        ? nextItem.nextElementSibling\n        : this.elm.querySelector('zane-tree-node:first-child');\n    } while (nextItem !== currentItem);\n  }\n\n  private focusPreviousItem(currentItem) {\n    let previousItem: any = currentItem.previousElementSibling;\n    do {\n      if (\n        previousItem &&\n        previousItem.tagName === 'ZANE-TREE-NODE' &&\n        !previousItem.disabled\n      ) {\n        previousItem.setFocus();\n        return;\n      }\n      previousItem = previousItem\n        ? previousItem.previousElementSibling\n        : this.elm.querySelector('zane-tree-node:last-child');\n    } while (previousItem !== currentItem);\n  }\n\n  private getFirstItem() {\n    return this.elm.querySelector('zane-menu-item');\n  }\n\n  private renderEmptyState() {\n    if (this.empty)\n      return (\n        <zane-empty-state class=\"empty-menu\" {...this.internalEmptyState} />\n      );\n  }\n}\n"],"mappings":"kDAAA,MAAMA,EAAU,wxF,MCyBHC,EAAI,MALjB,WAAAC,CAAAC,G,UAQ2BC,KAAKC,MAAY,MAEjBD,KAAAE,WAAqB,0FAW9CF,KAAWG,YAAU,EAiHtB,CA/GC,iBAAAC,GACEJ,KAAKK,iB,CAIP,qBAAMC,GACJ,OAAON,KAAKO,Y,CAId,aAAAC,CAAcC,GACZ,MAAMC,EAAOD,EAAIE,eACjB,IAAIC,EAAW,KACf,IAAK,MAAMC,KAAOH,EAAM,CACtB,GAAKG,EAAYC,UAAY,iBAAkB,CAC7CF,EAAWC,C,CAEb,GAAIA,IAAQb,KAAKa,IAAK,SACtB,GAAIJ,EAAIM,MAAQ,YAAa,CAC3BN,EAAIO,iBACJhB,KAAKiB,cAAcL,E,MACd,GAAIH,EAAIM,MAAQ,UAAW,CAChCN,EAAIO,iBACJhB,KAAKkB,kBAAkBN,E,GAM7B,eAAAP,GACEL,KAAKmB,0BACInB,KAAKE,aAAe,SACvBkB,KAAKC,MAAMrB,KAAKE,YAChBF,KAAKE,U,CAGb,MAAAoB,GACE,OAAOtB,KAAKC,MACVsB,EAAA,OAAKC,MAAM,aAAaxB,KAAKyB,oBAE7BF,EAAA,OAAKC,MAAM,aACTD,EAAa,a,CAUnB,cAAMG,GACJ,MAAMC,EAAgB3B,KAAK4B,eAC1BD,IAAqB,MAArBA,SAAa,SAAbA,EAAuBD,U,CAI1B,uBAAMG,CAAkBC,GACtB9B,KAAKG,YAAY4B,KAAKD,E,CAIxB,aAAAE,CAAcvB,GACZT,KAAKO,aAAeE,EAAIwB,OAAOC,MAC/BlC,KAAKG,YAAYgC,SAASL,GAAOA,EAAGrB,EAAIwB,OAAOC,Q,CAGzC,aAAAjB,CAAcmB,GACpB,IAAIC,EAAgBD,EAAYE,mBAChC,EAAG,CACD,GACED,GACAA,EAASvB,UAAY,mBACpBuB,EAASE,SACV,CACAF,EAASX,WACT,M,CAEFW,EAAWA,EACPA,EAASC,mBACTtC,KAAKa,IAAI2B,cAAc,6BAC7B,OAASH,IAAaD,E,CAGhB,iBAAAlB,CAAkBkB,GACxB,IAAIK,EAAoBL,EAAYM,uBACpC,EAAG,CACD,GACED,GACAA,EAAa3B,UAAY,mBACxB2B,EAAaF,SACd,CACAE,EAAaf,WACb,M,CAEFe,EAAeA,EACXA,EAAaC,uBACb1C,KAAKa,IAAI2B,cAAc,4BAC7B,OAASC,IAAiBL,E,CAGpB,YAAAR,GACN,OAAO5B,KAAKa,IAAI2B,cAAc,iB,CAGxB,gBAAAf,GACN,GAAIzB,KAAKC,MACP,OACEsB,EAAkB,mBAAAoB,OAAAC,OAAA,CAAApB,MAAM,cAAiBxB,KAAKmB,oB","ignoreList":[]}